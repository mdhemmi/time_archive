name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Triggers on version tags like v1.0.0
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: true
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, xml, curl, zip, gd, intl, bcmath
          coverage: none
          tools: composer

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'

      - name: Get version from tag or input
        id: get_version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Update version in info.xml
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          sed -i '' "s|<version>.*</version>|<version>$VERSION</version>|g" appinfo/info.xml || \
          sed -i "s|<version>.*</version>|<version>$VERSION</version>|g" appinfo/info.xml
          echo "Updated appinfo/info.xml to version $VERSION"

      - name: Install Composer dependencies
        run: |
          composer install --no-dev --optimize-autoloader --no-interaction --prefer-dist
        continue-on-error: false
        timeout-minutes: 10

      - name: Install npm dependencies
        run: |
          npm ci --prefer-offline --no-audit
        continue-on-error: false
        timeout-minutes: 10

      - name: Build frontend
        run: |
          npm run build

      - name: Verify build output
        run: |
          if [ ! -d "js" ] || [ -z "$(ls -A js/ 2>/dev/null)" ]; then
            echo "ERROR: No JavaScript files were generated!"
            exit 1
          fi
          echo "Build verification passed:"
          ls -lh js/ | tail -n +2

      - name: Create release archive
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          APP_NAME="time_archive"
          ARCHIVE_NAME="${APP_NAME}-${VERSION}.tar.gz"
          
          # Create a clean release directory
          mkdir -p /tmp/${APP_NAME}-release
          
          # Copy app files (exclude development files)
          rsync -av \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='node_modules' \
            --exclude='vendor' \
            --exclude='.gitignore' \
            --exclude='.editorconfig' \
            --exclude='.eslintrc.js' \
            --exclude='.stylelintrc.json' \
            --exclude='babel.config.js' \
            --exclude='tsconfig.json' \
            --exclude='webpack.config.js' \
            --exclude='package-lock.json' \
            --exclude='composer.lock' \
            --exclude='*.md' \
            --exclude='*.sh' \
            --exclude='tests' \
            --exclude='.phpunit.result.cache' \
            ./ /tmp/${APP_NAME}-release/${APP_NAME}/
          
          # Create tarball (tar.gz format required by Nextcloud)
          # Using explicit tar with gzip compression - NOT zip
          cd /tmp/${APP_NAME}-release
          
          # Remove any existing zip files (just in case)
          rm -f *.zip
          
          # Create tar.gz using tar with gzip compression
          tar -czf ${ARCHIVE_NAME} ${APP_NAME}/
          
          # Verify it's a tar.gz file (gzip compressed tar)
          # A tar.gz file will show as "gzip compressed data" from the file command
          FILE_TYPE=$(file ${ARCHIVE_NAME})
          echo "File type: ${FILE_TYPE}"
          
          # Check that it's gzip compressed (tar.gz files are gzip compressed)
          if ! echo "${FILE_TYPE}" | grep -qi "gzip"; then
            echo "ERROR: Archive is not a gzip compressed file!"
            echo "Expected: gzip compressed data"
            echo "Got: ${FILE_TYPE}"
            exit 1
          fi
          
          # Verify it's NOT a zip file (zip files show as "Zip archive")
          if echo "${FILE_TYPE}" | grep -qi "zip archive"; then
            echo "ERROR: Archive was created as ZIP instead of TAR.GZ!"
            echo "Got: ${FILE_TYPE}"
            exit 1
          fi
          
          # Verify archive structure (should contain app folder)
          if ! tar -tzf ${ARCHIVE_NAME} | head -1 | grep -q "^${APP_NAME}/"; then
            echo "ERROR: Archive structure is incorrect! Should start with ${APP_NAME}/"
            tar -tzf ${ARCHIVE_NAME} | head -5
            exit 1
          fi
          
          # Verify file extension is .tar.gz
          if [[ ! "${ARCHIVE_NAME}" =~ \.tar\.gz$ ]]; then
            echo "ERROR: Archive filename must end with .tar.gz, got: ${ARCHIVE_NAME}"
            exit 1
          fi
          
          # Move to workspace
          mv ${ARCHIVE_NAME} ${{ github.workspace }}/
          
          # Final verification
          FINAL_FILE="${{ github.workspace }}/${ARCHIVE_NAME}"
          echo "=== Archive Verification ==="
          ls -lh ${FINAL_FILE}
          file ${FINAL_FILE}
          echo "File extension: ${ARCHIVE_NAME##*.}"
          echo "✅ Created ${ARCHIVE_NAME} (tar.gz format - NOT zip)"

      - name: Sign app (if certificate available)
        if: env.SIGNING_CERTIFICATE != '' && env.SIGNING_KEY != ''
        env:
          SIGNING_CERTIFICATE: ${{ secrets.APP_SIGNING_CERTIFICATE }}
          SIGNING_KEY: ${{ secrets.APP_SIGNING_KEY }}
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          APP_NAME="time_archive"
          
          # Create certificate directory
          mkdir -p ~/.nextcloud/certificates
          
          # Write certificate and key from secrets
          echo "$SIGNING_CERTIFICATE" > ~/.nextcloud/certificates/${APP_NAME}.crt
          echo "$SIGNING_KEY" > ~/.nextcloud/certificates/${APP_NAME}.key
          chmod 600 ~/.nextcloud/certificates/${APP_NAME}.key
          
          # Extract tarball for signing
          mkdir -p /tmp/signing
          cd /tmp/signing
          tar -xzf ${{ github.workspace }}/${APP_NAME}-${VERSION}.tar.gz
          
          # Sign the app (requires Nextcloud server with occ)
          # Note: This step requires a Nextcloud installation or Docker container
          # For now, we'll create an unsigned archive and note it
          echo "⚠️  Signing requires Nextcloud server. Archive created but not signed."
          echo "⚠️  You'll need to sign manually using: php occ app:sign time_archive"

      - name: Create GitHub Release
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: |
            time_archive-${{ steps.get_version.outputs.version }}.tar.gz
          name: Release v${{ steps.get_version.outputs.version }}
          tag_name: v${{ steps.get_version.outputs.version }}
          body: |
            ## Version ${{ steps.get_version.outputs.version }}
            
            ### Changes
            - See git log for detailed changes
            
            ### Installation
            1. Download the `time_archive-${{ steps.get_version.outputs.version }}.tar.gz` file
            2. Extract to your Nextcloud `apps/` directory
            3. Run `php occ app:enable time_archive`
            
            ### App Store Release
            **Note**: This archive needs to be signed before uploading to the Nextcloud App Store.
            
            To sign:
            ```bash
            php occ app:sign time_archive \
              --privateKey=~/.nextcloud/certificates/time_archive.key \
              --certificate=~/.nextcloud/certificates/time_archive.crt \
              --path=/tmp
            ```
            
            Then upload the signed tarball to https://apps.nextcloud.com
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: false
        timeout-minutes: 5

      - name: Upload archive artifact (manual run)
        if: github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: time_archive-${{ steps.get_version.outputs.version }}
          path: time_archive-${{ steps.get_version.outputs.version }}.tar.gz
          retention-days: 30

      - name: Upload unsigned archive artifact (tag push without signing)
        if: github.event_name == 'push' && (env.SIGNING_CERTIFICATE == '' || env.SIGNING_KEY == '')
        uses: actions/upload-artifact@v4
        with:
          name: time_archive-${{ steps.get_version.outputs.version }}-unsigned
          path: time_archive-${{ steps.get_version.outputs.version }}.tar.gz
          retention-days: 30

      - name: Summary
        run: |
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Version: ${{ steps.get_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "✅ Archive created: time_archive-${{ steps.get_version.outputs.version }}.tar.gz" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.SIGNING_CERTIFICATE }}" == "" ]; then
            echo "⚠️  Archive is unsigned - sign manually before App Store upload" >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ Archive signed (if signing step succeeded)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the GitHub release" >> $GITHUB_STEP_SUMMARY
          echo "2. Sign the archive (if not already signed)" >> $GITHUB_STEP_SUMMARY
          echo "3. Upload signed archive to https://apps.nextcloud.com" >> $GITHUB_STEP_SUMMARY
